
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">golangwithgin/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">golangwithgin/config/config.go (0.0%)</option>
				
				<option value="file2">golangwithgin/docs/docs.go (0.0%)</option>
				
				<option value="file3">golangwithgin/internal/app/handlers/task_handler.go (0.0%)</option>
				
				<option value="file4">golangwithgin/internal/app/handlers/user_handler.go (0.0%)</option>
				
				<option value="file5">golangwithgin/internal/app/middlewares/auth_middleware.go (0.0%)</option>
				
				<option value="file6">golangwithgin/internal/app/middlewares/cors_middleware.go (0.0%)</option>
				
				<option value="file7">golangwithgin/internal/app/middlewares/logger_middleware.go (0.0%)</option>
				
				<option value="file8">golangwithgin/internal/app/routes/api_routes.go (0.0%)</option>
				
				<option value="file9">golangwithgin/internal/app/routes/v1/routes.go (0.0%)</option>
				
				<option value="file10">golangwithgin/internal/app/routes/v1/user_routes.go (0.0%)</option>
				
				<option value="file11">golangwithgin/internal/app/server/server.go (0.0%)</option>
				
				<option value="file12">golangwithgin/internal/domain/mocks/gomock_reflect_1798682728/prog.go (0.0%)</option>
				
				<option value="file13">golangwithgin/internal/domain/mocks/gomock_reflect_2011987148/prog.go (0.0%)</option>
				
				<option value="file14">golangwithgin/internal/domain/mocks/gomock_reflect_35589266/prog.go (0.0%)</option>
				
				<option value="file15">golangwithgin/internal/domain/mocks/task_processor_mock.go (0.0%)</option>
				
				<option value="file16">golangwithgin/internal/domain/mocks/task_repository_mock.go (0.0%)</option>
				
				<option value="file17">golangwithgin/internal/domain/mocks/task_service_mock.go (0.0%)</option>
				
				<option value="file18">golangwithgin/internal/domain/user.go (0.0%)</option>
				
				<option value="file19">golangwithgin/internal/repository/mysql/task_repository.go (0.0%)</option>
				
				<option value="file20">golangwithgin/internal/repository/mysql/user_mysql_repository.go (0.0%)</option>
				
				<option value="file21">golangwithgin/internal/service/task_processor.go (0.0%)</option>
				
				<option value="file22">golangwithgin/internal/service/task_service.go (90.5%)</option>
				
				<option value="file23">golangwithgin/internal/service/user_service.go (0.0%)</option>
				
				<option value="file24">golangwithgin/internal/testutil/helper.go (0.0%)</option>
				
				<option value="file25">golangwithgin/pkg/database/mysql.go (0.0%)</option>
				
				<option value="file26">golangwithgin/pkg/logger/logger.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "golangwithgin/config"
        "golangwithgin/internal/app/server"
        "golangwithgin/pkg/logger"

        _ "golangwithgin/docs" // Import generated Swagger docs

        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

// @title           GolangWithGin API
// @version         1.0
// @description     A RESTful API server using Go and Gin framework
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8889
// @BasePath  /api/v1

// @securityDefinitions.apikey Bearer
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.
func main() <span class="cov0" title="0">{
        // Initialize logger
        log := logger.New()

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to load configuration:", err)
        }</span>

        // Create and start server
        <span class="cov0" title="0">srv := server.New(cfg, log)
        
        // Add Swagger documentation route
        srv.Router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        if err := srv.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to start server:", err)
        }</span>
} </pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "github.com/spf13/viper"
        "time"
)

type Config struct {
        Server   ServerConfig   `mapstructure:"server"`
        Database DatabaseConfig `mapstructure:"database"`
        JWT      JWTConfig     `mapstructure:"jwt"`
        Logger   LoggerConfig
}

type ServerConfig struct {
        Port string `mapstructure:"port"`
}

type DatabaseConfig struct {
        Host     string `mapstructure:"host"`
        Port     int    `mapstructure:"port"`
        Username string `mapstructure:"username"`
        Password string `mapstructure:"password"`
        DBName   string `mapstructure:"dbname"`
}

type JWTConfig struct {
        Secret     string
        Expiration time.Duration
}

type LoggerConfig struct {
        Level string
        File  string
}

// Load reads configuration from environment variables and config files
func Load() (*Config, error) <span class="cov0" title="0">{
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath("./config")
        
        // Set defaults
        viper.SetDefault("server.port", "8888")
        viper.SetDefault("database.host", "localhost")
        viper.SetDefault("database.port", 3306)
        
        // Read from environment variables
        viper.AutomaticEnv()
        viper.SetEnvPrefix("APP")
        
        // Map environment variables
        viper.BindEnv("database.host", "DB_HOST")
        viper.BindEnv("database.port", "DB_PORT")
        viper.BindEnv("database.username", "DB_USER")
        viper.BindEnv("database.password", "DB_PASSWORD")
        viper.BindEnv("database.dbname", "DB_NAME")
        viper.BindEnv("jwt.secret", "JWT_SECRET")
        
        // Read config file
        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        
        <span class="cov0" title="0">var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;config, nil</span>
} </pre>
		
		<pre class="file" id="file2" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/login": {
            "post": {
                "description": "Authenticate a user and return a JWT token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "Login credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handlers.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/domain.TokenResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/register": {
            "post": {
                "description": "Register a new user in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Register new user",
                "parameters": [
                    {
                        "description": "User registration details",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handlers.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/domain.SwaggerUserResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/tasks": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get a list of all tasks",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Get all tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/domain.SwaggerTask"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Submit a new task for processing",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Create a new task",
                "parameters": [
                    {
                        "description": "Task details",
                        "name": "task",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.SwaggerTask"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/domain.SwaggerTask"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/tasks/{id}": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get a task's details and status by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "tasks"
                ],
                "summary": "Get task by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Task ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/domain.SwaggerTask"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/user": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get the profile of the currently authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get user profile",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/domain.SwaggerUserResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Update the profile of the currently authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Update user profile",
                "parameters": [
                    {
                        "description": "User update details",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handlers.UpdateUserRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/domain.SwaggerUserResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/user/{id}": {
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Delete a user by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Delete user",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/domain.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "domain.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string",
                    "example": "error message"
                }
            }
        },
        "domain.SwaggerTask": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string",
                    "example": "2025-05-31T15:04:05Z"
                },
                "description": {
                    "type": "string",
                    "example": "Process the uploaded data file"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "status": {
                    "type": "string",
                    "example": "pending"
                },
                "title": {
                    "type": "string",
                    "example": "Process Data"
                },
                "updated_at": {
                    "type": "string",
                    "example": "2025-05-31T15:04:05Z"
                }
            }
        },
        "domain.SwaggerUserResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string",
                    "example": "2025-05-31T15:04:05Z"
                },
                "email": {
                    "type": "string",
                    "example": "john@example.com"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "updated_at": {
                    "type": "string",
                    "example": "2025-05-31T15:04:05Z"
                },
                "username": {
                    "type": "string",
                    "example": "johndoe"
                }
            }
        },
        "domain.TokenResponse": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                }
            }
        },
        "handlers.LoginRequest": {
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string",
                    "example": "secretpass123"
                },
                "username": {
                    "type": "string",
                    "example": "johndoe"
                }
            }
        },
        "handlers.RegisterRequest": {
            "type": "object",
            "required": [
                "email",
                "password",
                "username"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "john@example.com"
                },
                "password": {
                    "type": "string",
                    "example": "secretpass123"
                },
                "username": {
                    "type": "string",
                    "example": "johndoe"
                }
            }
        },
        "handlers.UpdateUserRequest": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string",
                    "example": "john_updated@example.com"
                },
                "username": {
                    "type": "string",
                    "example": "johndoe_updated"
                }
            }
        }
    },
    "securityDefinitions": {
        "Bearer": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8889",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "GolangWithGin API",
        Description:      "A RESTful API server using Go and Gin framework",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "golangwithgin/internal/domain"
        "net/http"
        "strconv"
)

type TaskHandler struct {
        taskService domain.TaskService
}

func NewTaskHandler(taskService domain.TaskService) *TaskHandler <span class="cov0" title="0">{
        return &amp;TaskHandler{
                taskService: taskService,
        }
}</span>

// @Summary Create a new task
// @Description Submit a new task for processing
// @Tags tasks
// @Accept json
// @Produce json
// @Security Bearer
// @Param task body domain.SwaggerTask true "Task details"
// @Success 202 {object} domain.SwaggerTask
// @Failure 400 {object} domain.ErrorResponse
// @Failure 401 {object} domain.ErrorResponse
// @Failure 500 {object} domain.ErrorResponse
// @Router /tasks [post]
func (h *TaskHandler) CreateTask(c *gin.Context) <span class="cov0" title="0">{
        var task domain.Task
        if err := c.ShouldBindJSON(&amp;task); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if err := h.taskService.SubmitTask(&amp;task); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusAccepted, task)</span>
}

// @Summary Get task by ID
// @Description Get a task's details and status by its ID
// @Tags tasks
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "Task ID"
// @Success 200 {object} domain.SwaggerTask
// @Failure 400 {object} domain.ErrorResponse
// @Failure 401 {object} domain.ErrorResponse
// @Failure 404 {object} domain.ErrorResponse
// @Router /tasks/{id} [get]
func (h *TaskHandler) GetTask(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid task ID"})
                return
        }</span>

        <span class="cov0" title="0">task, err := h.taskService.GetTaskStatus(uint(id))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "task not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, task)</span>
}

// @Summary Get all tasks
// @Description Get a list of all tasks
// @Tags tasks
// @Accept json
// @Produce json
// @Security Bearer
// @Success 200 {array} domain.SwaggerTask
// @Failure 401 {object} domain.ErrorResponse
// @Failure 500 {object} domain.ErrorResponse
// @Router /tasks [get]
func (h *TaskHandler) GetAllTasks(c *gin.Context) <span class="cov0" title="0">{
        tasks, err := h.taskService.GetAllTasks()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, tasks)</span>
} </pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "golangwithgin/internal/domain"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
)

type UserHandler struct {
        userService domain.UserService
}

func NewUserHandler(userService domain.UserService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService: userService,
        }
}</span>

// @Summary Register new user
// @Description Register a new user in the system
// @Tags auth
// @Accept json
// @Produce json
// @Param user body RegisterRequest true "User registration details"
// @Success 201 {object} domain.SwaggerUserResponse
// @Failure 400 {object} domain.ErrorResponse
// @Failure 500 {object} domain.ErrorResponse
// @Router /register [post]
func (h *UserHandler) Register(c *gin.Context) <span class="cov0" title="0">{
        var req RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">user := &amp;domain.User{
                Username:  req.Username,
                Password:  req.Password,
                Email:     req.Email,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if err := h.userService.Register(user); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, user.ToResponse())</span>
}

// @Summary User login
// @Description Authenticate a user and return a JWT token
// @Tags auth
// @Accept json
// @Produce json
// @Param credentials body LoginRequest true "Login credentials"
// @Success 200 {object} domain.TokenResponse
// @Failure 400 {object} domain.ErrorResponse
// @Failure 401 {object} domain.ErrorResponse
// @Router /login [post]
func (h *UserHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">token, err := h.userService.Login(req.Username, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"token": token})</span>
}

// @Summary Get user profile
// @Description Get the profile of the currently authenticated user
// @Tags users
// @Accept json
// @Produce json
// @Security Bearer
// @Success 200 {object} domain.SwaggerUserResponse
// @Failure 401 {object} domain.ErrorResponse
// @Failure 500 {object} domain.ErrorResponse
// @Router /user [get]
func (h *UserHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")
        if userID == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user.ToResponse())</span>
}

// @Summary Update user profile
// @Description Update the profile of the currently authenticated user
// @Tags users
// @Accept json
// @Produce json
// @Security Bearer
// @Param user body UpdateUserRequest true "User update details"
// @Success 200 {object} domain.SwaggerUserResponse
// @Failure 400 {object} domain.ErrorResponse
// @Failure 401 {object} domain.ErrorResponse
// @Failure 500 {object} domain.ErrorResponse
// @Router /user [put]
func (h *UserHandler) UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")
        if userID == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">existingUser, err := h.userService.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if req.Username != "" </span><span class="cov0" title="0">{
                existingUser.Username = req.Username
        }</span>
        <span class="cov0" title="0">if req.Email != "" </span><span class="cov0" title="0">{
                existingUser.Email = req.Email
        }</span>
        <span class="cov0" title="0">existingUser.UpdatedAt = time.Now()

        if err := h.userService.Update(existingUser); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, existingUser.ToResponse())</span>
}

// @Summary Delete user
// @Description Delete a user by ID
// @Tags users
// @Accept json
// @Produce json
// @Security Bearer
// @Param id path int true "User ID"
// @Success 204 "No Content"
// @Failure 400 {object} domain.ErrorResponse
// @Failure 401 {object} domain.ErrorResponse
// @Failure 500 {object} domain.ErrorResponse
// @Router /user/{id} [delete]
func (h *UserHandler) DeleteUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user id"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.userService.Delete(uint(id)); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// Request/Response types
type RegisterRequest struct {
        Username string `json:"username" binding:"required" example:"johndoe"`
        Password string `json:"password" binding:"required" example:"secretpass123"`
        Email    string `json:"email" binding:"required,email" example:"john@example.com"`
}

type LoginRequest struct {
        Username string `json:"username" binding:"required" example:"johndoe"`
        Password string `json:"password" binding:"required" example:"secretpass123"`
}

type UpdateUserRequest struct {
        Username string `json:"username" example:"johndoe_updated"`
        Email    string `json:"email" binding:"omitempty,email" example:"john_updated@example.com"`
} </pre>
		
		<pre class="file" id="file5" style="display: none">package middlewares

import (
        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "net/http"
        "strings"
)

type AuthMiddleware struct {
        jwtSecret string
}

func NewAuthMiddleware(jwtSecret string) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                jwtSecret: jwtSecret,
        }
}</span>

func (m *AuthMiddleware) AuthRequired(c *gin.Context) <span class="cov0" title="0">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "authorization header is required"})
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid authorization header format"})
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">tokenString := parts[1]
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(m.jwtSecret), nil
        }</span>)

        <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token claims"})
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">userID := uint(claims["user_id"].(float64))
        c.Set("user_id", userID)
        c.Next()</span>
}

// GetUserID retrieves the authenticated user's ID from the context
func GetUserID(c *gin.Context) uint <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return userID.(uint)</span>
} </pre>
		
		<pre class="file" id="file6" style="display: none">package middlewares

import (
        "github.com/gin-gonic/gin"
)

func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
} </pre>
		
		<pre class="file" id="file7" style="display: none">package middlewares

import (
        "golangwithgin/pkg/logger"
        "time"

        "github.com/gin-gonic/gin"
)

func Logger(log *logger.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Start timer
                start := time.Now()

                // Process request
                c.Next()

                // Log only when path is not being skipped
                param := gin.LogFormatterParams{
                        Request: c.Request,
                        Keys:    c.Keys,
                }

                // Stop timer
                param.TimeStamp = time.Now()
                param.Latency = param.TimeStamp.Sub(start)

                log.WithFields(map[string]interface{}{
                        "status":     c.Writer.Status(),
                        "method":     param.Method,
                        "path":       param.Path,
                        "latency":    param.Latency,
                        "client_ip":  c.ClientIP(),
                        "user_agent": c.Request.UserAgent(),
                }).Info("HTTP Request")
        }</span>
} </pre>
		
		<pre class="file" id="file8" style="display: none">package routes

import (
        "golangwithgin/config"
        "golangwithgin/internal/app/handlers"
        "golangwithgin/internal/app/routes/v1"
        "golangwithgin/internal/domain"
        "golangwithgin/pkg/logger"

        "github.com/gin-gonic/gin"
)

func SetupRoutes(router *gin.Engine, cfg *config.Config, log *logger.Logger, userService domain.UserService) <span class="cov0" title="0">{
        // Create handlers
        userHandler := handlers.NewUserHandler(userService)

        // API v1 routes
        apiV1 := router.Group("/api/v1")
        v1.SetupUserRoutes(apiV1, userHandler, cfg.JWT.Secret)

        // Add more versioned routes here as needed
}</span> </pre>
		
		<pre class="file" id="file9" style="display: none">package v1

import (
        "github.com/gin-gonic/gin"
        "golangwithgin/internal/app/handlers"
        "golangwithgin/internal/app/middlewares"
)

func SetupRoutes(
        router *gin.Engine,
        userHandler *handlers.UserHandler,
        taskHandler *handlers.TaskHandler,
        authMiddleware *middlewares.AuthMiddleware,
) <span class="cov0" title="0">{
        v1 := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Public routes
                v1.POST("/register", userHandler.Register)
                v1.POST("/login", userHandler.Login)

                // Protected routes
                protected := v1.Group("/")
                protected.Use(authMiddleware.AuthRequired)
                </span><span class="cov0" title="0">{
                        // User routes
                        protected.GET("/user", userHandler.GetUser)
                        protected.PUT("/user", userHandler.UpdateUser)

                        // Task routes
                        protected.POST("/tasks", taskHandler.CreateTask)
                        protected.GET("/tasks", taskHandler.GetAllTasks)
                        protected.GET("/tasks/:id", taskHandler.GetTask)
                }</span>
        }
} </pre>
		
		<pre class="file" id="file10" style="display: none">package v1

import (
        "github.com/gin-gonic/gin"
        "golangwithgin/internal/app/handlers"
        "golangwithgin/internal/app/middlewares"
)

func SetupUserRoutes(
        router *gin.RouterGroup,
        userHandler *handlers.UserHandler,
        jwtSecret string,
) <span class="cov0" title="0">{
        // Create auth middleware
        authMiddleware := middlewares.NewAuthMiddleware(jwtSecret)

        // Public routes
        router.POST("/register", userHandler.Register)
        router.POST("/login", userHandler.Login)

        // Protected routes
        protected := router.Group("/")
        protected.Use(authMiddleware.AuthRequired)
        </span><span class="cov0" title="0">{
                protected.GET("/user", userHandler.GetUser)
                protected.PUT("/user", userHandler.UpdateUser)
        }</span>
} </pre>
		
		<pre class="file" id="file11" style="display: none">package server

import (
        "fmt"
        "golangwithgin/config"
        "golangwithgin/internal/app/handlers"
        "golangwithgin/internal/app/middlewares"
        "golangwithgin/internal/app/routes/v1"
        "golangwithgin/internal/repository/mysql"
        "golangwithgin/internal/service"
        "golangwithgin/pkg/database"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

type Server struct {
        Router *gin.Engine
        config *config.Config
        logger *logrus.Logger
}

// New creates a new server instance
func New(cfg *config.Config, logger *logrus.Logger) *Server <span class="cov0" title="0">{
        router := gin.Default()

        // Initialize database
        db, err := database.NewMySQLDB(cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to connect to database: %v", err)
        }</span>

        // Initialize repositories
        <span class="cov0" title="0">userRepo := mysql.NewUserRepository(db)
        taskRepo := mysql.NewTaskRepository(db)

        // Initialize task processor
        taskProcessor := service.NewTaskProcessor()

        // Initialize services
        userService := service.NewUserService(userRepo, cfg.JWT.Secret)
        taskService := service.NewTaskService(taskRepo, taskProcessor)

        // Initialize handlers
        userHandler := handlers.NewUserHandler(userService)
        taskHandler := handlers.NewTaskHandler(taskService)

        // Initialize middlewares
        authMiddleware := middlewares.NewAuthMiddleware(cfg.JWT.Secret)

        // Setup routes
        v1.SetupRoutes(router, userHandler, taskHandler, authMiddleware)

        return &amp;Server{
                Router: router,
                config: cfg,
                logger: logger,
        }</span>
}

// Start starts the server
func (s *Server) Start() error <span class="cov0" title="0">{
        addr := fmt.Sprintf(":%s", s.config.Server.Port)
        s.logger.Infof("Starting server on %s", addr)
        return s.Router.Run(addr)
}</span>

func (s *Server) Shutdown() {<span class="cov0" title="0">
        // No need to implement shutdown logic as the server is managed by gin
}</span>

// GetRouter returns the server's router instance
func (s *Server) GetRouter() *gin.Engine <span class="cov0" title="0">{
        return s.Router
}</span> </pre>
		
		<pre class="file" id="file12" style="display: none">
package main

import (
        "encoding/gob"
        "flag"
        "fmt"
        "os"
        "path"
        "reflect"

        "github.com/golang/mock/mockgen/model"

        pkg_ "golangwithgin/internal/domain"
)

var output = flag.String("output", "", "The output file name, or empty to use stdout.")

func main() <span class="cov0" title="0">{
        flag.Parse()

        its := []struct{
                sym string
                typ reflect.Type
        }{
                
                { "TaskRepository", reflect.TypeOf((*pkg_.TaskRepository)(nil)).Elem()},
                
        }
        pkg := &amp;model.Package{
                // NOTE: This behaves contrary to documented behaviour if the
                // package name is not the final component of the import path.
                // The reflect package doesn't expose the package name, though.
                Name: path.Base("golangwithgin/internal/domain"),
        }

        for _, it := range its </span><span class="cov0" title="0">{
                intf, err := model.InterfaceFromInterfaceType(it.typ)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Reflection: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">intf.Name = it.sym
                pkg.Interfaces = append(pkg.Interfaces, intf)</span>
        }

        <span class="cov0" title="0">outfile := os.Stdout
        if len(*output) != 0 </span><span class="cov0" title="0">{
                var err error
                outfile, err = os.Create(*output)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "failed to open output file %q", *output)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := outfile.Close(); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "failed to close output file %q", *output)
                                os.Exit(1)
                        }</span>
                }()
        }

        <span class="cov0" title="0">if err := gob.NewEncoder(outfile).Encode(pkg); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "gob encode: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">
package main

import (
        "encoding/gob"
        "flag"
        "fmt"
        "os"
        "path"
        "reflect"

        "github.com/golang/mock/mockgen/model"

        pkg_ "golangwithgin/internal/domain"
)

var output = flag.String("output", "", "The output file name, or empty to use stdout.")

func main() <span class="cov0" title="0">{
        flag.Parse()

        its := []struct{
                sym string
                typ reflect.Type
        }{
                
                { "TaskRepository", reflect.TypeOf((*pkg_.TaskRepository)(nil)).Elem()},
                
        }
        pkg := &amp;model.Package{
                // NOTE: This behaves contrary to documented behaviour if the
                // package name is not the final component of the import path.
                // The reflect package doesn't expose the package name, though.
                Name: path.Base("golangwithgin/internal/domain"),
        }

        for _, it := range its </span><span class="cov0" title="0">{
                intf, err := model.InterfaceFromInterfaceType(it.typ)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Reflection: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">intf.Name = it.sym
                pkg.Interfaces = append(pkg.Interfaces, intf)</span>
        }

        <span class="cov0" title="0">outfile := os.Stdout
        if len(*output) != 0 </span><span class="cov0" title="0">{
                var err error
                outfile, err = os.Create(*output)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "failed to open output file %q", *output)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := outfile.Close(); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "failed to close output file %q", *output)
                                os.Exit(1)
                        }</span>
                }()
        }

        <span class="cov0" title="0">if err := gob.NewEncoder(outfile).Encode(pkg); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "gob encode: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">
package main

import (
        "encoding/gob"
        "flag"
        "fmt"
        "os"
        "path"
        "reflect"

        "github.com/golang/mock/mockgen/model"

        pkg_ "golangwithgin/internal/domain"
)

var output = flag.String("output", "", "The output file name, or empty to use stdout.")

func main() <span class="cov0" title="0">{
        flag.Parse()

        its := []struct{
                sym string
                typ reflect.Type
        }{
                
                { "TaskRepository", reflect.TypeOf((*pkg_.TaskRepository)(nil)).Elem()},
                
        }
        pkg := &amp;model.Package{
                // NOTE: This behaves contrary to documented behaviour if the
                // package name is not the final component of the import path.
                // The reflect package doesn't expose the package name, though.
                Name: path.Base("golangwithgin/internal/domain"),
        }

        for _, it := range its </span><span class="cov0" title="0">{
                intf, err := model.InterfaceFromInterfaceType(it.typ)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Reflection: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">intf.Name = it.sym
                pkg.Interfaces = append(pkg.Interfaces, intf)</span>
        }

        <span class="cov0" title="0">outfile := os.Stdout
        if len(*output) != 0 </span><span class="cov0" title="0">{
                var err error
                outfile, err = os.Create(*output)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "failed to open output file %q", *output)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := outfile.Close(); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "failed to close output file %q", *output)
                                os.Exit(1)
                        }</span>
                }()
        }

        <span class="cov0" title="0">if err := gob.NewEncoder(outfile).Encode(pkg); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "gob encode: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: golangwithgin/internal/domain (interfaces: TaskProcessor)

// Package mocks is a generated GoMock package.
package mocks

import (
        domain "golangwithgin/internal/domain"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockTaskProcessor is a mock of TaskProcessor interface.
type MockTaskProcessor struct {
        ctrl     *gomock.Controller
        recorder *MockTaskProcessorMockRecorder
}

// MockTaskProcessorMockRecorder is the mock recorder for MockTaskProcessor.
type MockTaskProcessorMockRecorder struct {
        mock *MockTaskProcessor
}

// NewMockTaskProcessor creates a new mock instance.
func NewMockTaskProcessor(ctrl *gomock.Controller) *MockTaskProcessor <span class="cov0" title="0">{
        mock := &amp;MockTaskProcessor{ctrl: ctrl}
        mock.recorder = &amp;MockTaskProcessorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskProcessor) EXPECT() *MockTaskProcessorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Process mocks base method.
func (m *MockTaskProcessor) Process(arg0 *domain.Task) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Process", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Process indicates an expected call of Process.
func (mr *MockTaskProcessorMockRecorder) Process(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Process", reflect.TypeOf((*MockTaskProcessor)(nil).Process), arg0)
}</span>

// Shutdown mocks base method.
func (m *MockTaskProcessor) Shutdown() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Shutdown")
}</span>

// Shutdown indicates an expected call of Shutdown.
func (mr *MockTaskProcessorMockRecorder) Shutdown() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockTaskProcessor)(nil).Shutdown))
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: golangwithgin/internal/domain (interfaces: TaskRepository)

// Package mocks is a generated GoMock package.
package mocks

import (
        domain "golangwithgin/internal/domain"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockTaskRepository is a mock of TaskRepository interface.
type MockTaskRepository struct {
        ctrl     *gomock.Controller
        recorder *MockTaskRepositoryMockRecorder
}

// MockTaskRepositoryMockRecorder is the mock recorder for MockTaskRepository.
type MockTaskRepositoryMockRecorder struct {
        mock *MockTaskRepository
}

// NewMockTaskRepository creates a new mock instance.
func NewMockTaskRepository(ctrl *gomock.Controller) *MockTaskRepository <span class="cov0" title="0">{
        mock := &amp;MockTaskRepository{ctrl: ctrl}
        mock.recorder = &amp;MockTaskRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskRepository) EXPECT() *MockTaskRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockTaskRepository) Create(arg0 *domain.Task) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockTaskRepositoryMockRecorder) Create(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTaskRepository)(nil).Create), arg0)
}</span>

// FindAll mocks base method.
func (m *MockTaskRepository) FindAll() ([]*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAll")
        ret0, _ := ret[0].([]*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAll indicates an expected call of FindAll.
func (mr *MockTaskRepositoryMockRecorder) FindAll() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockTaskRepository)(nil).FindAll))
}</span>

// FindByID mocks base method.
func (m *MockTaskRepository) FindByID(arg0 uint) (*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", arg0)
        ret0, _ := ret[0].(*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockTaskRepositoryMockRecorder) FindByID(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockTaskRepository)(nil).FindByID), arg0)
}</span>

// Update mocks base method.
func (m *MockTaskRepository) Update(arg0 *domain.Task) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockTaskRepositoryMockRecorder) Update(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTaskRepository)(nil).Update), arg0)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: golangwithgin/internal/domain (interfaces: TaskService)

// Package mocks is a generated GoMock package.
package mocks

import (
        domain "golangwithgin/internal/domain"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockTaskService is a mock of TaskService interface.
type MockTaskService struct {
        ctrl     *gomock.Controller
        recorder *MockTaskServiceMockRecorder
}

// MockTaskServiceMockRecorder is the mock recorder for MockTaskService.
type MockTaskServiceMockRecorder struct {
        mock *MockTaskService
}

// NewMockTaskService creates a new mock instance.
func NewMockTaskService(ctrl *gomock.Controller) *MockTaskService <span class="cov0" title="0">{
        mock := &amp;MockTaskService{ctrl: ctrl}
        mock.recorder = &amp;MockTaskServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskService) EXPECT() *MockTaskServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAllTasks mocks base method.
func (m *MockTaskService) GetAllTasks() ([]*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllTasks")
        ret0, _ := ret[0].([]*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllTasks indicates an expected call of GetAllTasks.
func (mr *MockTaskServiceMockRecorder) GetAllTasks() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllTasks", reflect.TypeOf((*MockTaskService)(nil).GetAllTasks))
}</span>

// GetTaskStatus mocks base method.
func (m *MockTaskService) GetTaskStatus(arg0 uint) (*domain.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTaskStatus", arg0)
        ret0, _ := ret[0].(*domain.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTaskStatus indicates an expected call of GetTaskStatus.
func (mr *MockTaskServiceMockRecorder) GetTaskStatus(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTaskStatus", reflect.TypeOf((*MockTaskService)(nil).GetTaskStatus), arg0)
}</span>

// SubmitTask mocks base method.
func (m *MockTaskService) SubmitTask(arg0 *domain.Task) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SubmitTask", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SubmitTask indicates an expected call of SubmitTask.
func (mr *MockTaskServiceMockRecorder) SubmitTask(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubmitTask", reflect.TypeOf((*MockTaskService)(nil).SubmitTask), arg0)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package domain

import (
        "time"
)

// User represents a user entity
type User struct {
        ID        uint      `json:"id" gorm:"primaryKey"`
        Username  string    `json:"username" gorm:"unique"`
        Password  string    `json:"-"`
        Email     string    `json:"email" gorm:"unique"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

type UserRepository interface {
        Create(user *User) error
        FindByID(id uint) (*User, error)
        FindByEmail(email string) (*User, error)
        FindByUsername(username string) (*User, error)
        Update(user *User) error
        Delete(id uint) error
}

type UserService interface {
        Register(user *User) error
        Login(username, password string) (string, error) // Returns JWT token
        GetByID(id uint) (*User, error)
        Update(user *User) error
        Delete(id uint) error
}

// UserResponse is the DTO for user data
type UserResponse struct {
        ID        uint      `json:"id"`
        Email     string    `json:"email"`
        Username  string    `json:"username"`
        CreatedAt time.Time `json:"created_at"`
}

// ToResponse converts User to UserResponse
func (u *User) ToResponse() *UserResponse <span class="cov0" title="0">{
        return &amp;UserResponse{
                ID:        u.ID,
                Email:     u.Email,
                Username:  u.Username,
                CreatedAt: u.CreatedAt,
        }
}</span> </pre>
		
		<pre class="file" id="file19" style="display: none">package mysql

import (
        "golangwithgin/internal/domain"
        "gorm.io/gorm"
)

type taskRepository struct {
        db *gorm.DB
}

// NewTaskRepository creates a new task repository
func NewTaskRepository(db *gorm.DB) domain.TaskRepository <span class="cov0" title="0">{
        return &amp;taskRepository{db: db}
}</span>

func (r *taskRepository) Create(task *domain.Task) error <span class="cov0" title="0">{
        return r.db.Create(task).Error
}</span>

func (r *taskRepository) Update(task *domain.Task) error <span class="cov0" title="0">{
        return r.db.Save(task).Error
}</span>

func (r *taskRepository) FindByID(id uint) (*domain.Task, error) <span class="cov0" title="0">{
        var task domain.Task
        err := r.db.First(&amp;task, id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;task, nil</span>
}

func (r *taskRepository) FindAll() ([]*domain.Task, error) <span class="cov0" title="0">{
        var tasks []*domain.Task
        err := r.db.Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tasks, nil</span>
} </pre>
		
		<pre class="file" id="file20" style="display: none">package mysql

import (
        "golangwithgin/internal/domain"
        "gorm.io/gorm"
        "time"
)

type userRepository struct {
        db *gorm.DB
}

func NewUserRepository(db *gorm.DB) domain.UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{
                db: db,
        }
}</span>

func (r *userRepository) Create(user *domain.User) error <span class="cov0" title="0">{
        user.CreatedAt = time.Now()
        user.UpdatedAt = time.Now()
        return r.db.Create(user).Error
}</span>

func (r *userRepository) FindByID(id uint) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        err := r.db.First(&amp;user, id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) FindByEmail(email string) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        err := r.db.Where("email = ?", email).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) FindByUsername(username string) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        err := r.db.Where("username = ?", username).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) Update(user *domain.User) error <span class="cov0" title="0">{
        user.UpdatedAt = time.Now()
        return r.db.Model(user).Updates(map[string]interface{}{
                "username":   user.Username,
                "email":      user.Email,
                "password":   user.Password,
                "updated_at": user.UpdatedAt,
        }).Error
}</span>

func (r *userRepository) Delete(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;domain.User{}, id).Error
}</span> </pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "fmt"
        "golangwithgin/internal/domain"
        "sync"
        "time"
)

// TaskProcessor implements the TaskProcessor interface
type TaskProcessor struct {
        tasks      chan *domain.Task
        workers    int
        wg         sync.WaitGroup
        stopChan   chan struct{}
        resultPool *sync.Pool
}

// NewTaskProcessor creates a new task processor with the specified number of workers
func NewTaskProcessor() domain.TaskProcessor <span class="cov0" title="0">{
        processor := &amp;TaskProcessor{
                tasks:    make(chan *domain.Task, 100),
                workers:  5,
                stopChan: make(chan struct{}),
                resultPool: &amp;sync.Pool{
                        New: func() interface{} </span><span class="cov0" title="0">{
                                s := ""
                                return &amp;s
                        }</span>,
                },
        }

        <span class="cov0" title="0">processor.start()
        return processor</span>
}

func (p *TaskProcessor) start() <span class="cov0" title="0">{
        for i := 0; i &lt; p.workers; i++ </span><span class="cov0" title="0">{
                p.wg.Add(1)
                go p.worker()
        }</span>
}

func (p *TaskProcessor) worker() <span class="cov0" title="0">{
        defer p.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case task := &lt;-p.tasks:<span class="cov0" title="0">
                        // Get a result string from the pool
                        result := p.resultPool.Get().(*string)

                        // Process the task
                        *result = fmt.Sprintf("Processed task '%s' by worker %d at %v", task.Name, p.workers, time.Now())
                        
                        // Simulate some work
                        time.Sleep(time.Second)

                        // Update task status and result
                        task.Status = "completed"
                        task.Result = *result
                        task.UpdatedAt = time.Now()

                        // Put the result string back in the pool
                        p.resultPool.Put(result)</span>
                case &lt;-p.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (p *TaskProcessor) Process(task *domain.Task) error <span class="cov0" title="0">{
        task.Status = "processing"
        task.UpdatedAt = time.Now()
        p.tasks &lt;- task
        return nil
}</span>

// Shutdown gracefully shuts down the processor
func (p *TaskProcessor) Shutdown() <span class="cov0" title="0">{
        close(p.stopChan)
        p.wg.Wait()
        close(p.tasks)
}</span> </pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "golangwithgin/internal/domain"
        "time"
)

// taskService implements the TaskService interface
type taskService struct {
        repository domain.TaskRepository
        processor  domain.TaskProcessor
}

// NewTaskService creates a new task service
func NewTaskService(repository domain.TaskRepository, processor domain.TaskProcessor) domain.TaskService <span class="cov8" title="1">{
        return &amp;taskService{
                repository: repository,
                processor:  processor,
        }
}</span>

func (s *taskService) SubmitTask(task *domain.Task) error <span class="cov8" title="1">{
        // Set initial task state
        task.Status = "pending"
        task.CreatedAt = time.Now()
        task.UpdatedAt = time.Now()

        // Save task to database
        if err := s.repository.Create(task); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Process task asynchronously
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                // Update task status to processing
                task.Status = "processing"
                task.UpdatedAt = time.Now()
                if err := s.repository.Update(task); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // Process the task
                <span class="cov8" title="1">if err := s.processor.Process(task); err != nil </span><span class="cov8" title="1">{
                        task.Status = "failed"
                        task.Result = err.Error()
                }</span> else<span class="cov8" title="1"> {
                        task.Status = "completed"
                }</span>

                // Update task in database after processing
                <span class="cov8" title="1">task.UpdatedAt = time.Now()
                if err := s.repository.Update(task); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't return it since we're in a goroutine
                        // In a production system, you'd want to handle this error properly
                        return
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

func (s *taskService) GetTaskStatus(id uint) (*domain.Task, error) <span class="cov8" title="1">{
        return s.repository.FindByID(id)
}</span>

func (s *taskService) GetAllTasks() ([]*domain.Task, error) <span class="cov8" title="1">{
        return s.repository.FindAll()
}</span> </pre>
		
		<pre class="file" id="file23" style="display: none">package service

import (
        "errors"
        "golangwithgin/internal/domain"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/crypto/bcrypt"
)

type userService struct {
        repo      domain.UserRepository
        jwtSecret string
}

func NewUserService(repo domain.UserRepository, jwtSecret string) domain.UserService <span class="cov0" title="0">{
        return &amp;userService{
                repo:      repo,
                jwtSecret: jwtSecret,
        }
}</span>

func (s *userService) Register(user *domain.User) error <span class="cov0" title="0">{
        // Hash password
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">user.Password = string(hashedPassword)

        // Set timestamps
        user.CreatedAt = time.Now()
        user.UpdatedAt = time.Now()

        return s.repo.Create(user)</span>
}

func (s *userService) Login(username, password string) (string, error) <span class="cov0" title="0">{
        user, err := s.repo.FindByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("invalid credentials")
        }</span>

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil </span><span class="cov0" title="0">{
                return "", errors.New("invalid credentials")
        }</span>

        // Generate JWT token
        <span class="cov0" title="0">token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id": user.ID,
                "exp":     time.Now().Add(24 * time.Hour).Unix(),
        })

        tokenString, err := token.SignedString([]byte(s.jwtSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

func (s *userService) GetByID(id uint) (*domain.User, error) <span class="cov0" title="0">{
        return s.repo.FindByID(id)
}</span>

func (s *userService) Update(user *domain.User) error <span class="cov0" title="0">{
        user.UpdatedAt = time.Now()
        return s.repo.Update(user)
}</span>

func (s *userService) Delete(id uint) error <span class="cov0" title="0">{
        return s.repo.Delete(id)
}</span> </pre>
		
		<pre class="file" id="file24" style="display: none">package testutil

import (
        "golangwithgin/internal/domain"
        "time"
)

// CreateTestTask creates a task for testing
func CreateTestTask() *domain.Task <span class="cov0" title="0">{
        return &amp;domain.Task{
                ID:          1,
                Name:        "Test Task",
                Description: "Test Description",
                Status:      "pending",
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }
}</span>

// CreateTestTasks creates multiple tasks for testing
func CreateTestTasks(count int) []*domain.Task <span class="cov0" title="0">{
        tasks := make([]*domain.Task, count)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                tasks[i] = &amp;domain.Task{
                        ID:          uint(i + 1),
                        Name:        "Test Task " + string(rune(i+1)),
                        Description: "Test Description " + string(rune(i+1)),
                        Status:      "pending",
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                }
        }</span>
        <span class="cov0" title="0">return tasks</span>
} </pre>
		
		<pre class="file" id="file25" style="display: none">package database

import (
        "fmt"
        "golangwithgin/config"
        "time"

        "gorm.io/driver/mysql"
        "gorm.io/gorm"
)

// NewMySQLDB creates a new MySQL database connection
func NewMySQLDB(cfg config.DatabaseConfig) (*gorm.DB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&amp;tls=false",
                cfg.Username,
                cfg.Password,
                cfg.Host,
                cfg.Port,
                cfg.DBName,
        )

        db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get database instance: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">sqlDB.SetMaxIdleConns(10)
        sqlDB.SetMaxOpenConns(100)
        sqlDB.SetConnMaxLifetime(time.Hour)

        return db, nil</span>
} </pre>
		
		<pre class="file" id="file26" style="display: none">package logger

import (
        "golangwithgin/config"
        "io"
        "os"

        "github.com/sirupsen/logrus"
)

type Logger struct {
        *logrus.Logger
}

func NewLogger(cfg *config.LoggerConfig) *Logger <span class="cov0" title="0">{
        logger := logrus.New()

        // Set log level
        level, err := logrus.ParseLevel(cfg.Level)
        if err != nil </span><span class="cov0" title="0">{
                level = logrus.InfoLevel
        }</span>
        <span class="cov0" title="0">logger.SetLevel(level)

        // Set log format
        logger.SetFormatter(&amp;logrus.JSONFormatter{
                TimestampFormat: "2006-01-02 15:04:05",
        })

        // Set output
        var output io.Writer = os.Stdout
        if cfg.File != "" </span><span class="cov0" title="0">{
                file, err := os.OpenFile(cfg.File, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err == nil </span><span class="cov0" title="0">{
                        output = io.MultiWriter(os.Stdout, file)
                }</span>
        }
        <span class="cov0" title="0">logger.SetOutput(output)

        return &amp;Logger{
                Logger: logger,
        }</span>
}

// Additional helper methods can be added here
func (l *Logger) WithFields(fields map[string]interface{}) *logrus.Entry <span class="cov0" title="0">{
        return l.Logger.WithFields(fields)
}</span>

func (l *Logger) WithError(err error) *logrus.Entry <span class="cov0" title="0">{
        return l.Logger.WithError(err)
}</span>

// New creates a new logger instance
func New() *logrus.Logger <span class="cov0" title="0">{
        log := logrus.New()
        log.SetFormatter(&amp;logrus.TextFormatter{
                FullTimestamp: true,
        })
        return log
}</span> </pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
